import { Grid, Color, EMPTY } from "../types/grid";
import { Point, neighbors4 } from "../types/point";
import { Snake } from "../types/snake";
import { OutsideGrid } from "./outside-grid";

//! Because the snake can't traverse 'backward', so a safe path (not dead) must be a round trip path -- 'route'

// Summary:

// path: Any sequence of points for snake movement (generic, may not be safe for round-trip).
// tunnel: A validated, round-trip path that guarantees the snake can enter, consume, and exit safely (used for optimal clearing).
// Tunnels are a subset of paths, with additional safety and round-trip guarantees.

// There may be 'dead path', but won't be 'dead route'.

export class Tunnel {
  // A tunnel is a special path formed with a series of points
  private path: Point[];

  constructor(path: Point[] = []) {
    this.path = [...path];
  }

  /**
   * Get the tunnel path as array of points
   */
  toArray(): Point[] {
    return [...this.path];
  }

  /**
   * Check if tunnel is empty
   */
  isEmpty(): boolean {
    return this.path.length === 0;
  }

  /**
   * Get tunnel length
   */
  getLength(): number {
    return this.path.length;
  }

  /**
   * Removes empty cells from the start (tail side) of the tunnel path.
   *
   * Iteratively removes leading positions from the tunnel while those positions
   * are considered empty in the provided grid. This is useful to discard already
   * consumed or irrelevant cells at the start of a tunnel.
   *
   * @param grid - The grid used to determine whether a cell is empty.
   */
  trimStart(grid: Grid): void {
    while (this.path.length > 0) {
      const point = this.path[0];
      if (this.isEmptySafe(grid, point.x, point.y)) {
        this.path.shift();
      } else {
        break;
      }
    }
  }

  /**
   * Removes empty cells from the end (head side) of the tunnel path.
   *
   * Iteratively removes trailing positions from the tunnel when they are empty
   * or duplicated earlier in the path. This helps keep the tunnel focused on
   * relevant positions the snake must traverse.
   *
   * @param grid - The grid used to determine whether a cell is empty.
   */
  trimEnd(grid: Grid): void {
    while (this.path.length > 0) {
      const lastIndex = this.path.length - 1;
      const point = this.path[lastIndex];
      if (
        this.isEmptySafe(grid, point.x, point.y) ||
        this.path.findIndex((p) => p.x === point.x && p.y === point.y) < lastIndex
      ) {
        this.path.pop();
      } else {
        break;
      }
    }
  }

  /**
   * Trims empty cells from both ends of the tunnel path.
   *
   * Removes empty cells from the start and end of the tunnel path so that the
   * tunnel contains only meaningful positions. This is useful after simulating
   * consumption or when cleaning up paths generated by the pathfinder.
   *
   * @param grid - The grid used to determine whether a cell is empty.
   */
  trim(grid: Grid): void {
    this.trimStart(grid);
    this.trimEnd(grid);
  }

  /**
   * Updates the tunnel by removing consumed points from both ends.
   *
   * @param grid - The grid used to determine whether a cell is empty.
   * @param toDelete - Array of points to be removed from the tunnel.
   */
  update(grid: Grid, toDelete: Point[]): void {
    // Remove consumed points from start
    while (this.path.length > 0) {
      const point = this.path[0];
      if (
        this.isEmptySafe(grid, point.x, point.y) ||
        toDelete.some((p) => p.x === point.x && p.y === point.y)
      ) {
        this.path.shift();
      } else {
        break;
      }
    }

    // Remove consumed points from end
    while (this.path.length > 0) {
      const point = this.path[this.path.length - 1];
      if (
        this.isEmptySafe(grid, point.x, point.y) ||
        toDelete.some((p) => p.x === point.x && p.y === point.y)
      ) {
        this.path.pop();
      } else {
        break;
      }
    }
  }

  /**
   * Computes a priority score for the tunnel.
   *
   * The score balances two factors: the count of cells equal to
   * `targetColor` (primary benefit) and the cumulative difference of lower-color cells relative to the target color
   * (secondary weight). Duplicate positions are counted only once (first occurrence). The implementation iterates over
   * the tunnel path, counts unique cells with `targetColor` and accumulates weight for lower-color cells; it then
   * returns `lowerColorWeight / colorCount` unless `colorCount == 0`, in which case a sentinel `99999` is returned to indicate an extreme preference.
   *
   * @param grid - The current Grid used to inspect cell colors.
   * @param targetColor - The color level being targeted.
   * @returns Numeric score: higher values indicate a better tunnel (higher priority). Returns 99999 when the tunnel contains no targetColor cells (most desirable for residual clearing).
   */
  getPriority(grid: Grid, targetColor: Color): number {
    let colorCount = 0;
    let lowerColorWeight = 0;

    for (let i = 0; i < this.path.length; i++) {
      const point = this.path[i];
      const color = Tunnel.getColorSafe(grid, point.x, point.y);

      // Only count unique cells (first occurrence)
      if (
        !grid.isEmptyCell(color) &&
        i === this.path.findIndex((p) => p.x === point.x && p.y === point.y)
      ) {
        if ((color as number) === (targetColor as number)) {
          colorCount += 1;
        } else {
          lowerColorWeight += (targetColor as number) - (color as number);
        }
      }
    }

    if (colorCount === 0) return 99999; // Infinite priority for pure lower-color tunnels

    //! Favor tunnels with higher lower/current ratio
    //! When the count of the cells with lower color is more, and the count of the cells with target color is lesser,
    //! the priority is higher and should be the tunnel preferred
    return lowerColorWeight / colorCount;
  }

  /**
   * Clones this tunnel, returning a new Tunnel instance with the same path.
   *
   * @returns A new Tunnel instance with the same path.
   */
  clone(): Tunnel {
    return new Tunnel(this.path);
  }

  /**
   * Converts the tunnel path into a sequence of Snake states representing each movement along the tunnel.
   *
   * @param startSnake - The initial Snake state before entering the tunnel.
   * @returns An array of Snake states, each representing the snake after a move along the tunnel (in movement order).
   */
  getTunnelPath(startSnake: Snake): Snake[] {
    const movements: Snake[] = [];
    let currentSnake = startSnake;

    for (let i = 1; i < this.path.length; i++) {
      const currentHead = currentSnake.getHead();
      const target = this.path[i];
      const dx = target.x - currentHead.x;
      const dy = target.y - currentHead.y;

      currentSnake = currentSnake.nextSnake(dx, dy);
      movements.unshift(currentSnake);
    }

    return movements;
  }



  /**
   * Finds the best tunnel from a specific cell to the outside boundary.
   *
   * Creates a validated round-trip tunnel from a start position to the outside grid.
   * Performs a two-phase tunnel construction:
   * - Phase 1: Find escape path from start to outside boundary
   * - Phase 2: Simulate consumption and find return path to outside
   * The resulting tunnel is trimmed to remove empty cells at both ends.
   *
   * @param grid - The game grid containing colors and empty cells.
   * @param outsideGrid - Helper class that defines the "outside" boundary areas.
   * @param startX - X coordinate of the starting position.
   * @param startY - Y coordinate of the starting position.
   * @param maxColor - Maximum allowed color value for pathfinding (higher colors are blocked).
   * @param snakeLength - Length of the snake (affects collision detection and positioning).
   * @returns A valid Tunnel object if a round-trip path exists, null otherwise.
   */
  static findBestTunnel(
    grid: Grid,
    outsideGrid: OutsideGrid,
    startX: number,
    startY: number,
    maxColor: Color,
    snakeLength: number
  ): Tunnel | null {
    // Following SNK's getBestTunnel pattern exactly
    const startPoint = new Point(startX, startY);
    const snake = Snake.fromSinglePoint(startPoint, snakeLength);

    // Phase 1: Find escape path from start position (like SNK's first getSnakeEscapePath call)
    const one = this.findEscapePath(grid, outsideGrid, snake, maxColor);
    if (!one) return null;

    // Create snake at target position following SNK's approach
    const snakeICells = one.slice(0, snakeLength);
    while (snakeICells.length < snakeLength) {
      snakeICells.push(snakeICells[snakeICells.length - 1]);
    }
    const snakeI = this.createSnakeAtPosition(snakeICells, snakeLength);

    // Remove consumed colors from grid (following SNK's pattern)
    const gridI = grid.clone();
    for (const point of one) {
      this.setEmptySafe(gridI, point.x, point.y);
    }

    // Phase 2: Find second escape path (like SNK's second getSnakeEscapePath call)
    const two = this.findEscapePath(gridI, outsideGrid, snakeI, maxColor);
    if (!two) return null;

    // Combine paths following SNK's exact pattern:
    // one.shift() - remove first element
    // one.reverse() - reverse the path
    // one.push(...two) - append second path
    one.shift();           // Remove first element like SNK
    one.reverse();         // Reverse like SNK
    one.push(...two);      // Append second path like SNK

    // Apply SNK's trimming
    const tunnel = new Tunnel(one);
    tunnel.trimStart(grid);  // SNK's trimTunnelStart
    tunnel.trimEnd(grid);    // SNK's trimTunnelEnd

    return tunnel.isEmpty() ? null : tunnel;
  }

  /**
   * Finds an escape path for the snake's head to the outside boundary using BFS.
   *
   * Searches for a path from the current snake position to any cell considered "outside"
   * the grid, using a breadth-first search (BFS) algorithm with a cost function. The search only considers
   * valid moves (no self-collision, color constraints) and returns the shortest path found for the snake's head.
   *
   * @param grid - The game grid containing colors and empty cells.
   * @param outsideGrid - Helper class that defines the "outside" boundary areas.
   * @param snake - The current snake instance (position and body).
   * @param maxColor - Maximum allowed color value for traversable cells.
   * @returns An array of Points representing the head positions along the escape path, or null if no path exists.
   * @remarks This function actually only finds an escape path for the snake's head.
   */
  private static findEscapePath(
    grid: Grid,
    outsideGrid: OutsideGrid,
    snake: Snake,
    maxColor: Color
  ): Point[] | null {
    interface SearchNode {
      snake: Snake;
      parent: SearchNode | null;
      cost: number;
    }

    const openList: SearchNode[] = [{ snake, parent: null, cost: 0 }];
    const closedList: Snake[] = [];

    while (openList.length > 0) {
      const current = openList.shift()!;
      const head = current.snake.getHead();

      // Check if we reached outside
      //! For BFS, the first one will be the shortest one
      if (outsideGrid.isOutside(head.x, head.y)) {
        return this.reconstructPath(current);
      }

      // Try all directions
      for (const direction of neighbors4) {
        const newX = head.x + direction.x;
        const newY = head.y + direction.y;
        const cellColor = Tunnel.getColorSafe(grid, newX, newY);

        if (
          (cellColor as number) <= (maxColor as number) &&
          !current.snake.willSelfCollide(direction.x, direction.y)
        ) {
          const newSnake = current.snake.nextSnake(direction.x, direction.y);

          //! Here the closedList avoids duplicate snake positions (body positions), that means the same cell can be
          //! 'visited' multiple times
          if (!closedList.some((s) => s.equals(newSnake))) {
            //! Higher cost for target color cells to discourage their use, only when cell color equal to maxColor, it
            //! will have a much higher cost
            const moveCost = (cellColor as number) === (maxColor as number) ? 1000 : 1;
            const cost = current.cost + 1 + moveCost;

            //! This makes sure the one with lowest cost will be chosen first
            this.sortedInsert(openList, { snake: newSnake, parent: current, cost });
            closedList.push(newSnake);
          }
        }
      }
    }

    return null;
  }

  /**
   * Reconstructs a path of head positions from a search node back to the root.
   *
   * Starting from the provided goal node (which contains a snake and a parent link),
   * this function walks the parent chain and collects the head position of each snake
   * encountered. The resulting array contains the sequence of head positions from the
   * goal back to the starting node (the caller may reverse or use as-is depending on
   * the intended ordering).
   *
   * @param goalNode - The search node representing the goal state; nodes link to parents.
   * @returns An array of Points representing head positions from goal to start.
   */
  private static reconstructPath(goalNode: { snake: Snake; parent: any | null }): Point[] {
    const path: Point[] = [];
    let current = goalNode;

    // Collect heads from goal to start, then reverse to match snk ordering (start → goal)
    while (current) {
      path.push(current.snake.getHead());
      current = current.parent;
    }

    path.reverse();
    return path;
  }

  /**
   * Creates a snake at a specific position with a given length.
   *
   * Constructs a snake whose body follows the given path.
   * The path is an array of positions (from earliest to latest), where the first element
   * becomes the tail and the last element becomes the head. If the path is shorter than
   * the required snake length, the last position is repeated to pad the body.
   *
   * @param path - Array of positions representing the movement history (tail to head).
   * @param length - Desired length of the snake.
   * @returns A Snake instance with its body constructed from the path.
   */
  private static createSnakeAtPosition(path: Point[], length: number): Snake {
    const cells = path.slice(0, length);

    //! The path length may shorter than the required length of a snake, we padding it repeatedly with the last element
    //!  of the path. Visually it's a 'short' snake without tail
    while (cells.length < length) {
      cells.push(cells[cells.length - 1]);
    }
    return new Snake(cells);
  }

  /**
   * Inserts a node in sorted order by cost into the provided list.
   *
   * @param list - The list to insert into.
   * @param node - The node to insert, which must have a cost property.
   */
  private static sortedInsert(list: any[], node: any): void {
    let insertIndex = 0;
    while (insertIndex < list.length && node.cost >= list[insertIndex].cost) {
      insertIndex++;
    }
    list.splice(insertIndex, 0, node);
  }

  /**
   * Safely retrieves the color value at the specified grid coordinates.
   *
   * Returns the cell color if (x, y) is inside the grid; otherwise returns EMPTY.
   * This method prevents out-of-bounds errors by checking grid boundaries before accessing cell color.
   * It is commonly used in tunnel validation and pathfinding routines to ensure safe color queries.
   *
   * @param grid - The Grid object to query.
   * @param x - The x-coordinate of the cell.
   * @param y - The y-coordinate of the cell.
   * @returns The color value at (x, y) or EMPTY if out of bounds.
   */
  private static getColorSafe(grid: Grid, x: number, y: number): Color | typeof EMPTY {
    return grid.isInside(x, y) ? grid.getColor(x, y) : EMPTY;
  }

  /**
   * Checks if the specified cell is empty or out of bounds.
   *
   * @param grid - The Grid object to query.
   * @param x - The x-coordinate of the cell.
   * @param y - The y-coordinate of the cell.
   * @returns True if the cell is empty or out of bounds, false otherwise.
   */
  private isEmptySafe(grid: Grid, x: number, y: number): boolean {
    return !grid.isInside(x, y) || grid.isEmptyCell(grid.getColor(x, y));
  }

  /**
   * Sets the specified cell to empty if it is inside the grid.
   *
   * @param grid - The Grid object to modify.
   * @param x - The x-coordinate of the cell.
   * @param y - The y-coordinate of the cell.
   */
  private static setEmptySafe(grid: Grid, x: number, y: number): void {
    if (grid.isInside(x, y)) {
      grid.setColorEmpty(x, y);
    }
  }
}
